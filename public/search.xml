<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[gradle 构建多模块 spring boot 工程]]></title>
    <url>%2F2019%2F09%2F16%2Fgradlew-build-multi-module-project%2F</url>
    <content type="text"><![CDATA[这篇文章中，我通过IntelliJ IDEA来使用gradle + springBoot构建多模块工程。 创建多模块工程 首先，要新建一个rootProject，进行File -&gt; New -&gt; Project，进入到新建工程的界面 在这个界面的左边选择创建spring工程，右边选择jdk版本，可以看到还可以选择构建spring的初始化工具，默认是使用了spring官方提供的，大家也可以通过这个网址来初始化一个spring工程。 第二步，填写rootProject的信息，注意Type要选择Gradle Project，然后选择一下java版本 第三步，选择rootProject需要的一些依赖，比如devTools，SQL之类的，这个大家就按需选择吧 第四步，填写一下工程名称和路径，然后点finish，rootProject就创建成功啦 第五步，开始在rootProject中创建子模块，直接右键rootProject的工程名，然后选择New -&gt; Module，就可以开始新建子模块了，具体的过程跟刚才新建project是一摸一样的，这里就不赘述啦，大家记得写好module的名字就好。 构建好一个包含多个子模块的工程，我们的重点就要开始啦。我构建的rootProject叫做circe，包含了两个子模块，一个是dao，一个是web。 配置gradle 首先，编辑rootProject的settings.gradle，此时应该只有一句rootProject.name = &#39;circe&#39;，现在我们将子模块加入其中，加入 1include &apos;:dao&apos;, &apos;:web&apos; 表示该rootProject包含了dao和web两个subProject，因为我不需要在rootProject中写代码，所以把rootProject的src文件删掉了。 然后在rootProject的build.gradle文件中的dependencies部分中加入 12implementation &apos;:dao&apos;implementation &apos;:web&apos; 依然在此文件中加入allprojects模块，来配置公共的属性（allprojects和刚才的dependencies是同级的，直接写在build.gradle中即可）。我的配置如下 123456allprojects &#123; sourceCompatibility = &apos;11&apos; group = &apos;com.circe&apos; version = &apos;0.0.1-SNAPSHOT&apos;&#125; 再给rootProject的build.gradle加入 12bootJar.enabled = falsejar.enabled = true 这一步是因为我们最终要把所有的东西打成一个包，因为没有明显的程序入口，所以一直会报错，错误信息如下： 12345678 Execution failed for task &apos;:bootJar&apos;.&gt; Could not resolve all files for configuration &apos;:runtimeClasspath&apos;.&gt; Could not find :dao:. Required by: project : &gt; Could not find :web:. Required by: project : 其实我对于这个问题还不是很懂，以后搞懂了回来更新一下原因。一开始觉得需要指定一下mainClassName，但是上网查资料，各种排列组合一直也成功不了，所以现在只能暂时禁用bootJar，启用jar来解决这个问题。gradle中有各种各样的plugin可以进行这个打包操作，其中比较常用有jar和shadowJar，jar需要的配置比较少，相对的功能也就比较单一，只能满足最基本的需求，比如使用一些基本的类组成整个工程；如果需要在工程中加入一些其他的脚本之类的，可能就需要使用shadowJar来打包了。 然后可以在子模块的build.gradle文件的dependencies部分中加入 1compile project(&apos;:dao&apos;) 来表示子模块与其他模块的依赖，这里我的工程是web模块会依赖到dao模块，所以加入了这个配置，如果大家不需要也可以不加 最后，删除子模块build.gradle文件中的plugins部分中的version的信息，因为rootProject的版本号可能会与子模块的起冲突。 然后我们再在命令行中运行./gradlew clean build，就可以构建成功了。 多模块工程构建成功的比较直观标志就是，在rootProject目录中执行./gradlew clean build，rootProject和subProject中均会出现build目录，此处可以参照一下我的构建结果。]]></content>
      <tags>
        <tag>gradle</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo搭建博客遇到的一些问题总结]]></title>
    <url>%2F2019%2F09%2F11%2Fhexo-build-blog%2F</url>
    <content type="text"><![CDATA[上传图片 一开始，我是把图片放到本地，然后在文章中使用![]()相对路径的方式引入图片，但是本地看着没有问题，运行起来就会出现图片不显示的问题，可能是有需要配置的地方漏掉了。而且把图片存在本地也会有图片越来越多，整个文件越来越大的问题，所以我就把图片全都存在了cloudinary里。 cloudinary是一个免费的，类似于百度云的网站，可以自己上传图片，然后就可以通过生成的网址来访问这张图片。用在博客里非常方便，并且也不会有占用内存的情况。 图片上传成功后，可以直接点击copy url的按钮复制链接，非常的方便容易上手。 访问域名404 我第二次deploy的时候，发现怎么都不能通过我购买的域名来访问博客了，只能通过githubPage的url来访问，访问我购买的域名一直显示的是404，一度以为我的域名坏掉了，后来才发现我repo的设置github Page的custom domain部分被清空了 原来是每次提交之后都会刷新这部分内容，如果要通过域名访问，这部分是必须要如图填写的。 但是难道每次deploy之后都得来设置一下吗？这也太麻烦了，上网查了一下，原来只要在博客目录下的source目录下添加一个名为CNAME的文件，里面写入自己的域名即可，具体操作如下图 deploy之后，查看github repo的设置，当github Page部分的设置显示这样，就意味着域名部分的设置已经成功啦～ 一些常用的hexo命令 hexo new &quot;blogName&quot; //新建文章（可以缩写为 hexo n &quot;blogName&quot;） hexo generate //生成静态文件（可以缩写为 hexo g） hexo server //启动本地服务（可以缩写为 hexo s） hexo deploy //部署到github（可以缩写为 hexo d） hexo help //查看帮助 hexo s -g //组合命令：生成静态文件并启动本地服务 hexo d -g //组合命令：生成静态文件并部署到github]]></content>
      <tags>
        <tag>搭建博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo g 无法生成 index.html 文件]]></title>
    <url>%2F2019%2F09%2F10%2Fhexo-g-failed%2F</url>
    <content type="text"><![CDATA[今天在对博客进行一些基本设置之后，在执行hexo generate的时候，突然出现了很多错误 看提示我们知道，是依赖加载失败了，导致很多文件没有创建成功。 这时我们需要运行一下 1npm ls --depth 0 来查看依赖安装情况，我的执行结果如下图 可以看出有五个包都missing了，所以我们只需要挨个执行npm install就可以了，比如 1npm install hexo-generator-archive@^0.1.5 把该安装的依赖安装好，就可以愉快的执行hexo g 和 hexo s 在本地启动啦～]]></content>
      <tags>
        <tag>搭建博客</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
